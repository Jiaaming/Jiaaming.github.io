<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>算法 on James Liu&#39;s Space</title>
    <link>http://localhost:1313/tags/%E7%AE%97%E6%B3%95/</link>
    <description>Recent content in 算法 on James Liu&#39;s Space</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-gb</language>
    <lastBuildDate>Sat, 13 Aug 2022 00:00:00 +0000</lastBuildDate><atom:link href="http://localhost:1313/tags/%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[转载]关于时间复杂度与P、NP问题</title>
      <link>http://localhost:1313/posts/chapter-4/</link>
      <pubDate>Sat, 13 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/posts/chapter-4/</guid>
      
      <description>&lt;p&gt;&lt;a href=&#34;http://www.matrix67.com/blog/archives/105&#34;&gt;文章原地址&lt;/a&gt;@matrix67&lt;/p&gt;
&lt;p&gt;关于时间复杂度：&lt;/p&gt;
&lt;p&gt;&amp;ldquo;时间复杂度并不是表示一个程序解决问题需要花多少时间，而是: &lt;br&gt;
&lt;strong&gt;当问题规模扩大后，程序需要的时间长度增长得有多快&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;对于高速处理数据的计算机来说，处理某一个特定数据的效率不能衡量一个程序的好坏，而应该看当这个数据的规模变大到数百倍后，程序运行时间是否还是一样，或者也跟着慢了数百倍，或者变慢了数万倍。不管数据有多大，程序处理花的时间始终是那么多的，我们就说这个程序很好，具有O(1)的时间复杂度，也称常数级复杂度；数据规模变得有多大，花的时间也跟着变得有多长，这个程序的时间复杂度就是O(n)，比如找n个数中的最大值；而像冒泡排序、插入排序等，数据扩大2倍，时间变慢4倍的，属于O(n^2)的复杂度。还有一些穷举类的算法，所需时间长度成几何阶数上涨，这就是O(a^n)的指数级复杂度，甚至O(n!)的阶乘级复杂度。不会存在O(2&lt;em&gt;n^2)的复杂度，因为前面的那个“2”是系数，根本不会影响到整个程序的时间增长。同样地，O (n^3+n^2)的复杂度也就是O(n^3)的复杂度。因此，我们会说，一个O(0.01&lt;/em&gt;n^3)的程序的效率比O(100*n^2)的效率低，尽管在n很小的时候，前者优于后者，但后者时间随数据规模增长得慢，最终O(n^3)的复杂度将远远超过O(n^2)。我们也说，O(n^100)的复杂度小于O(1.01^n)的复杂度。&lt;/p&gt;
&lt;p&gt;容易看出，前面的几类复杂度被分为两种级别，其中后者的复杂度无论如何都远远大于前者：一种是O(1),O(log(n)),O(n^a)等，我们把它叫做多项式级的复杂度，因为它的规模n出现在底数的位置；另一种是O(a^n)和O(n!)型复杂度，它是非多项式级的，其复杂度计算机往往不能承受。当我们在解决一个问题时，我们选择的算法通常都需要是多项式级的复杂度，非多项式级的复杂度需要的时间太多，往往会超时，除非是数据规模非常小。&amp;rdquo;&lt;/p&gt;</description>
      
    </item>
    
  </channel>
</rss>
